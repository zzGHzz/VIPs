---
VIP: 200
Title: Implementation of SURFACE BFT Protocol
Author: Ziheng Zhou (peter.zhou@vechain.com) and Zhijie Ren (zhijie.ren@vechain.com)
Category: Core
Status: Draft
CreatedAt: 2019-08-09
---

# Overview

This proposal outlines the implementation of the Byzantine Fault Tolerance (BFT) protocol described in [1]. 

# Specification

## Definitions

1. Quorum certificate (`QC`) = `N` - `f` where `N` is the total number of nodes participating in the consensus process and `f` the presumed maximum number of malicious nodes. 
2. We say that two blocks **conflict** each other if they are on two different branches.

## Block

The basic idea is to let blocks carry messages about the local BFT state of the producer and committee members so that other nodes can update their local BFT states accordingly to reach the BFT consensus about a certain block, which gives the block finality. 

The local BFT state of a node consists of the references to four blocks: the block representing the current new view, the block that is prepared, the block that is pre-committed and the block that is committed by the node, respectively. See [1] for details about the definitions.

When producing a new block, the block producer needs to include his local BFT state in the block proposal and the committee members, or backers, will only back the proposal if the state matches theirs. After that, the producer needs to include the state, as the messages to all the other nodes, in the new block. However, when validating the new block, the messages will not be considered and therefore, will not affect the block's validation process.
 

We call the state included in the block the **Finality Vector**. The four block references are named the NEW-VIEW (`nv`), PREPARED (`pp`), PRE-COMMITTED (`pc`) and COMMITTED (`cm`) message, respectively. Based on the current Thor implementation, we can add a new field to represent the finality vector as follows:
```go
type headerBody struct {
	...
	FinalityVector [4]thor.Bytes32
}
```
Here the elements of `FinalityVector` are either zeros, meaning empty, or IDs of the blocks they refer to. 

## View

A view is defined as a chain of blocks satisfying that every block, except the first block `b0`, contains a `nv` message pointing to `b0`. In case the block ID is used as the reference, since it is not possible to know the ID of `b0` when generating it, the `nv` message of `b0` can be defined as `[block number of b0 (4 bytes) | zeros (28 bytes)]`.

We then define the following functions attached to a view:
```go
type view interface {
    hasQCForNV() bool
    hasQCForPP() (bool, thor.Bytes32)
    hasQCForPC() (bool, thor.Bytes32)
    getNumSigOnPC(pc thor.Bytes32) uint
    hasConflictPC() bool
}
```
* `hasQCForNV` checks whether the blocks in the view whose (non-duplicate) set of producers and backers is of a size no smaller than `QC`.
* `hasQCForPP` checks whether there is a `pp` message included in the blocks in the viewwhose (non-duplicate) set of producers and backers is of a size no smaller than `QC`. It returns the `pp` message value if yes.
* `hasQCForPC` checks whether there is a `pc` message included in the blocks in the viewwhose (non-duplicate) set of producers and backers is of a size no smaller than `QC`. It returns the `pc` message value if yes.
* `getNumSigOnPC` returns the size of the (non-duplicate) set of producers and backers of the blocks that include a `pc` message equal to the input.
* `hasConflictPC` checks whether there is a `pc` message in the view that refers to a block that is on another branch.

## Notations
Here are some notations that will be used in the rest of this article. We use `s` to denote the local BFT state and use `s.nv`, `s.pp`, `s.pc` and `s.cm` to represent the four block references included in `s`. Moreover, the `nv`, `pp`, `pc`, and `cm` messages in a block `b` are expressed as `b.nv`, `b.pp`, `b.pc` and `b.cm`.

## Ready To be Pre-Committed (RTPC)
Block `b` is called *ready to be pre-committed*, or RTPC, if there exists a view `v0` such that the following conditions hold:

1. `ok, pp := v0.hasQCForPP()` such that `ok == true && pp == b.ID()`
2. For any view `v1` newer than `v0`, that is the first block of `v1` is generated later than the first block of `v0`, if `v1.hasQCForNV() == true` then `v1.getNumSigOnPC(B.pc) > 0`
3. `B` is newer than the last block committed locally

Note that the RTPC block is not necessarily on the canonical chain. Moreover, it is guaranteed that there will be at most one RTPC block at all time for any honest node. 

## Main BFT Consensus Process

Note that each node needs to maintain two extra variables during the consensus process:

1. `lastSigned`: reference to the last block that is signed by the node either as the producer or backer and contains non-empty `pc` message.
2. `hasLastSignedpPCExpired`: a boolean variable indicating whether the current `lastSigned` has expired. 

Given a newly received valid **HEAVY** block `b`, we run the following procedure to update `s`.

1. Construct view `v` that includes `b`.
2. Update `s.cm` as follows:
```go
if ok, pc := v.hasQCForPC(); ok && !v.hasConflictPC() {
    s.cm = pc
    s.pc = thor.Bytes32{}
}
```
3. If `b.cm` is newer than `s.cm`, check all the blocks that include the same `cm` message as `b.cm`. Construct a set of all the block producers and backers and if the set contains at least QC non-duplicate elements, then set `s.cm = b.cm`.
4. If `b.cm` is changed, update the RTPC block.
5. Update the RTPC block given `b`.
6. Update `hasLastSignedPCExpired` as:
```go
if v.hasQCForNV() && v.getNumSigOnPC(lastSignedBlock.pc) == 0 {
    pcSignedExpired = true
}
```
7. If there is an RTPC block, either when `lastSigned.pc` does not conflict the block or `hasLastSignedPCExpired == true`, assign the reference to the RTPC block to `s.pc`.
8. If `s.pc` does not refer to the current RTPC block, unlock `s.pc`, that is, to assign an empty reference (e.g., `thor.Bytes32{}`) to `s.pc`.
9. If `b` is the head of the canonical chain, `v.hasQCForNV() == true` and `v.HasConflictPC() == false`, then assign the reference to the first block of `v` to `s.pp`.
10. If `b` is the head of the canonical chain, update `b.nv` as follows:
  * Let `b0` and `b1` be the block referred to by `s.nv` and `b.nv`, respectively. If `s.nv` is empty or `b0` is earlier than `b1`, then assign the reference to `b1` to `s.nv`.
  * Else if the node has just switched from one branch to the current branch, in other words, the parent block of `b` is not the head of the canonical chain locally seen by the node last time, assign the reference to `b` to `s.nv`.
11. If `s.nv` and `s.pp` conflict each other, unlock `s.pp`, that is, to assign an empty reference (e.g., `thor.Bytes32{}`) to `s.pp`.

# References

[1] Ren, Z. and Z. Zhou (2020) SURFACE: A Practical Blockchain Consensus Algorithm for Real-World Networks, arXiv:2002.07565.
